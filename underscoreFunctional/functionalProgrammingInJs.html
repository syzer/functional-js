<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>UnderscoreVsWuFunctionalJS</title>
</head>
<body>
//TODO open console
</body>
<script type="text/javascript" src="underscore.js"></script>
<script type="text/javascript" src="wu-0.1.8.js"></script>
<script>

//for me
var echo = function(x){console.log(x)};

/**
 * currying - a f() that will return a new f() untill recives all arguments 
 */
var add = function(x) {
    return function(y) {
        return x + y;
    }
}
var add3 = add(3); //function(y){}
add3(2);    //5
add3(5)     //8
add(5)(3); //weird!!

//solution:
//wu.autoCurry(fn);
var add = wu.autoCurry(function (a,b,c) {return a + b + c ;});
echo (add(1)()()()(2)()(3)); //6
echo (add(1,1,1));  //3

var add = function(x) {
    return function(y) {
        return x + y;
    };
};
//var value = add(5)(2);  //weird

var addBetter = function(x,y) {
    return x + y;
}.autoCurry();

var add3 = addBetter(3);
addBetter(3,5); //8
add3(4); //7

var fullName = function(first,middle, last) {
    return first + ' ' + middle + ' ' + last; 
}.autoCurry();

fullName("Bill", "Cosby", "Johnson") //""

//modulo :D
var modulo = function(divisor, dividend) {
    return dividend % divisor;
}

var isOdd = modulo(2);
echo("modulo");
echo(isOdd(6));

var filter = function(f, xs) {
    return xs.filter(f);
}.autoCurry();
filter(isOdd, [1,2,3,4,5]); //[1,3,5]

var getOdds = filter(isOdd);  // composing functions

var firstTwoLetters = function(words) {
    return _.map(words, function(word) {
       return _.first(word, 2); 
    });
};
firstTwoLetters(['jim', 'kate']);  //['ji', 'ka']

//if arg were reversed u could map into
var firstTwo = _.map(_.first(2));   //and you could use it 
//_.map(first(2), ['jim', 'kate']);

//API underscore prevents you from curring
//because arguments are backwords

/**
 * composition, kinda like chain but backwards 
 */
//but stupid underscore use chains
//compose _.compose(*function);
 
var last = function(xs) {
    var sx = reverse(xs);
    return first(sx);
}
var last = compose(first, reverse);
last([1,2,3]); //3 //u can use more than 2 functions

var wordCount = function(str) {
    var words = split(' ', str);
    return length(words);
}
//or better
var wordCount = compose(lenght, split(' '));  //   :D

wordCount("sting sadasd asd adsasas");

var createComment = function(html) {
    return Comment.create(replace('&quote;', '"', html));
};
//create html->Comment
createComment = compose(Comment.create, replace('&quote;', '"'));

A: f(x)-> A: g(x) -> B
map A to A and then B

//equals to
A: f()g() -> B

var sortedPhones = function(users) {
    return _.chain(users)
            .sortBt(function(user)) { return user.signup_date ; })
            .map(function(user){ return user.phone; })
            .value();
}
//chain can go to :

var sortedPhones = compose(
        _.map(function(user) { return user.phone;})
        _.sortBy(function(user) {return user.singup_date; }));

//or better to
//dot!!!!
var dot = function() {
    return obj[prop];
}.autoCurry();

var sortedPhones = compose(_.map(dot('phone')), _sortBy(dot('signup_date')));
sortedPhones(users);

alertAndClose = compose(scloseWin, alertInvited);

callApi = compose(fmap(alertAndClose), Repo.Student.inviteParents);

extractParams = compose(mconcat, map(Field));

sendInvite = compose(fmap(inviteParents), extractParams, getTextFields);

inviteParents = compose(callApi, merge(user_id_param));


//tail recursion -> or use high order function

/**
 * functors!!!!!!!!!!!!!!!
 */
//when u define map pn object -> u got functor

//problem:

var plus1 = function(x) { return x + 1};

//i want to do plus1[3];

map(plus1, [3]);

//map also work with OBJECTS!!!!
map( function(x) { return " I am "+ x}, MyObject("yo")) //"I am yo";

map( function(x) { return x.id}, MyObject({id: 3})); //3

map(plus1, MyObject(3))     //MyObject(4)

MyObject = function(val) {
    this.val= val;
}

MyObject.prototype.map = function(f) {
    return MyObject(f(this.val));
}

//maybe
Maybe = function(val) {
    this.val = val;
}

map(plus1, Maybe(3));   //  =>  Maybe(3)   => dynamic type safty
map(plus1, Maybe(null)) //  =>  Maybe(null)
Maybe.prototype.map = function(f) {
    return this.val ? Maybe(f(this.val)) : Maybe(null);
}

Either = function(left, right) {
    this.left = left;
    this.right = right;
}

map(plus1, Either(1, 2))            //Either(1 ,3)
map(plus1, Either(1, null))         //Either(2, null)

Either.prptotype.map = function(f) {
    return this.right ?
            Either(this.lelf, f(this.right)) :
            Either(f(this.left), null);
}

map(populateTable, $.ajax.get('/posts'));

Promise.prototype.map = function(f) {
    var promise = new Promise();
    this.then(function(response){
       promise.resolve(f(response)); 
    });
    return promise;
}

$div = $("#myDiv");
//User ->string
var getGreeting = compose(concat('Welcome '), dot('name'));
// User-> undefined
var updateGreetingHtml = compose($div.html, getGreeting);

updateGreetingHtml(App.current_user);
//to =>
map(updateGreetingHtml, Maybe(App.current_user));
//or with default 
map(updateGreetingHtml, Either({name: "blanky"}, App.current_user));

map(updateGreetingHtml, Promise(App.current_user));
        
/**
 * random stuff
 */
 
//underscore prevents extending map??
//why?? wtf??

//change behavior without aletring open/close principle
//not just map - reduce, compose, etc
//intuition and "non proprietary" api
//free formulas
//dynamic type safety

//score under
//traversables
//lences


</script>
</html>
